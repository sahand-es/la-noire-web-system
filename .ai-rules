# AI Rules for Django Project

This project follows **PROJECT-en.md** (L.A. Noire web system, two checkpoints: back-end first with DRF, then front-end). The rules below apply to back-end and stay aligned with that document.

## Design Principles
- Keep it simple and minimal. Do not over-engineer solutions.
- Prefer Django's built-in features over external packages when possible.
- Follow Django's "batteries included" philosophy.
- Avoid premature optimization.

## Project Structure
- Use `config/` for project-level settings (settings.py, urls.py, wsgi.py, asgi.py)
- Use `core/` app for shared models, utilities, and base classes
- Create new apps only when there's a clear domain separation
- Keep apps focused and cohesive

## Model Definition
- All models should inherit from `core.models.BaseModel` for timestamps
- Use meaningful field names and appropriate field types
- Add `__str__` methods to models for better admin representation
- Use `related_name` for ForeignKey and ManyToMany relationships
- Keep models simple - avoid complex business logic in models

Example:
```python
from core.models import BaseModel

class MyModel(BaseModel):
    name = models.CharField(max_length=100)
    
    def __str__(self):
        return self.name
```

## Code Style
- Do not over-comment. Only add function-level docstrings when necessary.
- No inline comments explaining obvious code
- Keep functions small and focused
- Use descriptive variable and function names instead of comments
- Follow PEP 8 style guide

## Naming Conventions
- **Files and modules:** `snake_case` (e.g. `user.py`, `case_resolution.py`).
- **Classes:** `PascalCase`. Models and choices: `Case`, `CaseStatus`, `Complaint`. ViewSets: `{Resource}ViewSet` (e.g. `CaseViewSet`, `RewardViewSet`). API views: `{Resource}{Action}View` or `{Action}View` (e.g. `UserRegistrationView`, `UserProfileView`). Serializers: `{Resource}{UseCase}Serializer` (e.g. `CaseListSerializer`, `ComplaintCreateSerializer`, `OfficerReviewSerializer`). Permission classes: `Is{Role}` or `Is{Role}Or{Role}` (e.g. `IsOfficer`, `IsCadetOrOfficer`). Admin: `{Model}Admin`. Mixins: `{Purpose}Mixin` (e.g. `CaseEvidenceMixin`).
- **Variables and functions:** `snake_case` (e.g. `validated_data`, `get_queryset`). Method names on ViewSets: `snake_case` (e.g. `officer_review`, `cadet_review`).
- **Constants and enum values:** `UPPER_SNAKE` for module/settings constants (e.g. `SECRET_KEY`, `DEBUG`). Model choices: use `UPPER_SNAKE` for the value, PascalCase for the class (e.g. `class CaseStatus(TextChoices): PENDING = 'pending'`).
- **URL paths and route names:** Path segments and `url_path` in `@action`: `kebab-case` (e.g. `biological-evidence`, `officer-reviews`, `assigned-detective`). URL name in `path()`: `kebab-case` (e.g. `case-witness-testimonies`, `case-biological-evidence-detail`).
- **Model fields and JSON keys:** `snake_case` (e.g. `created_at`, `reward_code`, `assigned_detective`). Same for API request/response keys unless a client convention requires otherwise.
- **related_name:** `snake_case`, plural when it returns multiple (e.g. `related_name='complaints'`), singular for ForeignKey back-ref when one (e.g. `related_name='case'`).

## Django Best Practices
- Use class-based views when appropriate, function-based views for simple cases
- Keep views thin - move business logic to services or model methods
- Use Django's ORM efficiently - avoid N+1 queries
- Register models in admin.py for models that need admin interface
- Use migrations for all database changes

## Admin Interface
- Register models in admin.py with minimal configuration
- Only customize admin if necessary
- Use `list_display`, `list_filter`, `search_fields` when helpful

## API/Views
- Use Django REST Framework for all API endpoints
- Keep views simple and focused
- Return appropriate HTTP status codes
- Handle errors gracefully
- Implement proper permission checks for each endpoint
- Use serializers for request/response validation

## REST API Design
- Follow RESTful conventions strictly
- Use appropriate HTTP methods: GET (read), POST (create), PUT/PATCH (update), DELETE (delete)
- Use plural nouns for resource names: `/api/users/`, `/api/items/`, `/api/products/`
- Use nested resources when appropriate: `/api/users/{id}/orders/`
- Return consistent JSON response format
- Include proper error messages in error responses
- Use status codes correctly: 200 (success), 201 (created), 400 (bad request), 401 (unauthorized), 403 (forbidden), 404 (not found), 500 (server error)

## CRUD Endpoints
- Create only necessary CRUD endpoints - not more, not less
- Each model that needs management should have: list, create, retrieve, update, delete endpoints
- Use ViewSets when appropriate for standard CRUD operations
- Custom actions should use `@action` decorator in ViewSets
- Group related endpoints logically

## Structure of Views and Serializers

**ViewSet structure**
- One ViewSet per resource. Set `queryset` with `select_related()` / `prefetch_related()` and default ordering.
- Use `get_serializer_class()` to return the right serializer per action: create → `*CreateSerializer`, list → `*ListSerializer`, retrieve → `*DetailSerializer`, custom actions → action-specific serializer (or `None` if no body).
- Use `get_permissions()` to return action-specific permission classes (e.g. create → `IsAuthenticated`, custom action → `IsOfficer()`).
- Override `get_queryset()` when list/retrieve must be filtered by user or role.
- Override `create`, `retrieve`, or `list` only when you need a custom response shape or logic; otherwise rely on the default behavior.
- Custom process endpoints: `@action(detail=True, methods=['post'], url_path='kebab-case')`. Use `get_object_or_404` when the action targets a specific instance. Return `Response({'status': 'success', 'data': serializer.data})` or `Response({'status': 'error', 'message': '...'}, status=...)`.
- Imports: models from `core.models`, serializers from `core.serializers.<module>`, permissions from `core.permissions`.

**Serializer structure**
- Use separate serializers per use case: `*CreateSerializer`, `*ListSerializer`, `*DetailSerializer`, `*UpdateSerializer` for CRUD; plus plain `Serializer` classes for custom action request bodies (e.g. `OfficerReviewSerializer` with `action = ChoiceField(...)`, `message = CharField(...)`).
- ModelSerializer: set `Meta.model` and `Meta.fields`. Add read-only display fields with `SerializerMethodField()` or `CharField(source='relation.get_full_name', read_only=True)`.
- For action input only (no model): use `serializers.Serializer` with explicit fields and `validate()` / `validate_<field>()` when needed. Add a short docstring only when the serializer’s role is not obvious.
- Keep create/update logic in the serializer when it’s about defaults and validation; keep workflow and side effects (status changes, notifications) in the view.

Example ViewSet (excerpt):

```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404

from core.models import Complaint, ComplaintStatus
from core.serializers.complaint import (
    ComplaintSerializer,
    ComplaintCreateSerializer,
    ComplaintUpdateSerializer,
    OfficerReviewSerializer,
)
from rest_framework.permissions import IsAuthenticated
from core.permissions import IsOfficer

class ComplaintViewSet(viewsets.ModelViewSet):
    queryset = Complaint.objects.select_related(
        'complainant', 'reviewed_by_cadet', 'reviewed_by_officer', 'case'
    ).all()

    def get_serializer_class(self):
        if self.action == 'create':
            return ComplaintCreateSerializer
        if self.action in ['update', 'partial_update']:
            return ComplaintUpdateSerializer
        return ComplaintSerializer

    def get_permissions(self):
        if self.action == 'officer_review':
            return [IsOfficer()]
        return [IsAuthenticated()]

    def get_queryset(self):
        user = self.request.user
        if user.has_role('Cadet'):
            return self.queryset.filter(status=ComplaintStatus.PENDING_CADET)
        if user.has_any_role(['Police Officer', ...]):
            return self.queryset.filter(status=ComplaintStatus.PENDING_OFFICER)
        return self.queryset.filter(complainant=user)

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        complaint = serializer.save()
        return Response(
            {'status': 'success', 'data': ComplaintSerializer(complaint).data, 'message': '...'},
            status=status.HTTP_201_CREATED
        )

    @action(detail=True, methods=['post'], url_path='officer-reviews')
    def officer_review(self, request, pk=None):
        complaint = get_object_or_404(Complaint, pk=pk, status=ComplaintStatus.PENDING_OFFICER)
        ser = OfficerReviewSerializer(data=request.data)
        ser.is_valid(raise_exception=True)
        # ... apply action, then:
        return Response({'status': 'success', 'data': ComplaintSerializer(complaint).data})
```

Example serializers (excerpt):

```python
from rest_framework import serializers
from core.models import Complaint

class ComplaintCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Complaint
        fields = ['title', 'description', 'incident_date', 'incident_location']

    def create(self, validated_data):
        validated_data['complainant'] = self.context['request'].user
        validated_data['status'] = ComplaintStatus.PENDING_CADET
        return super().create(validated_data)

class ComplaintSerializer(serializers.ModelSerializer):
    complainant_name = serializers.CharField(source='complainant.get_full_name', read_only=True)

    class Meta:
        model = Complaint
        fields = ['id', 'title', 'complainant', 'complainant_name', 'status', 'created_at', ...]

class OfficerReviewSerializer(serializers.Serializer):
    """Officer: approve (create case) or return to cadet."""
    action = serializers.ChoiceField(choices=['approve', 'reject'])
    message = serializers.CharField(required=False, allow_blank=True)

    def validate(self, data):
        if data['action'] == 'reject' and not data.get('message'):
            raise serializers.ValidationError({'message': 'Message required when rejecting.'})
        return data
```

## Entity Models
Model design principles:
- Design models accurately based on domain requirements
- Use appropriate relationships (ForeignKey, ManyToMany, OneToOne)
- Add status fields where workflow states are needed
- Include necessary fields for statistics and reporting
- Keep models normalized but practical
- Consider User/Profile models with role support when needed

## Role-Based Access Control (RBAC)
- Implement role-based permissions using Django's permission system
- Roles must be configurable without code changes (database-driven)
- Use Django's Group model or custom Role model for role management
- Create/update/delete roles via API endpoints
- Assign permissions to roles dynamically
- Check permissions in views/permissions classes
- Use DRF permissions classes: `IsAuthenticated`, custom permission classes
- Each endpoint must verify user's role and permissions before processing

Example permission check:
```python
from rest_framework.permissions import BasePermission

class HasRequiredRole(BasePermission):
    def has_permission(self, request, view):
        return request.user.groups.filter(name='required_role').exists()
```

## Authentication & Authorization
- Implement user registration endpoint
- Implement login endpoint (return JWT token or session)
- Use Django's authentication system
- Protect all endpoints with authentication except registration/login
- Return 401 for unauthenticated requests
- Return 403 for unauthorized requests (wrong role/permission)

## Process Endpoints
Process endpoint guidelines:
- Each business process should have a dedicated endpoint
- Process endpoints may update multiple related entities
- Use custom actions with `@action` decorator for process endpoints
- Return appropriate status and messages
- Validate business rules before processing
- Handle edge cases and errors gracefully
- Process endpoints should be idempotent when possible

## Statistics Endpoints
- Create endpoints for aggregated statistics
- Create endpoints for overall statistics
- Use Django ORM aggregations (Count, Sum, Avg, etc.)
- Optimize queries to avoid N+1 problems
- Return statistics in clear JSON format
- Group statistics by relevant dimensions (date, status, role, etc.)

## Testing
- Write tests for critical business logic
- Use Django's TestCase for model and view tests
- Keep tests simple and readable

## Dependencies
- Only add packages when absolutely necessary
- Prefer well-maintained, widely-used packages
- Keep requirements.txt minimal

## Database
- Use PostgreSQL (configured via docker-compose)
- Run migrations for all schema changes
- Do not modify migrations manually after they've been applied

## API Response Format
- Use consistent response structure across all endpoints
- Success responses should include data and status
- Error responses should include error message and status code
- Use DRF's standard response format or custom format consistently

Example success:
```json
{
  "status": "success",
  "data": {...}
}
```

Example error:
```json
{
  "status": "error",
  "message": "Error description",
  "code": 400
}
```

## Access Control Implementation
- Every API endpoint must check user authentication
- Every API endpoint must check user's role and permissions
- Return 401 for missing/invalid authentication
- Return 403 for insufficient permissions
- Log access attempts for security auditing
- Use DRF's permission classes consistently

## Commit Messages
- Use imperative mood, lowercase subject (e.g. "add X", "fix Y", "change Z")
- Prefer the structured format when scope is clear: `type[scope]: short description`
  - Types: `feat`, `fix`, `doc`, `build`, `refactor` (use `refactor` for "change X into Y" style)
  - Scope: area affected, e.g. `models`, `project`, `AI`, or app name
- Short commits may use the simple form: "add reward", "add evidence", "corrected django"
- Keep subject line under ~72 characters; add a body line only when needed for context (e.g. "not sure what was the problem")
- Do not add a trailing period to the subject line

Examples:
- `feat[models]: add initial models placeholders`
- `doc[AI]: add ai rules`


## General Guidelines
- Write code as if a human developer would write it - natural and straightforward
- Avoid AI-typical patterns like excessive type hints, over-documentation, or overly defensive code
- Prefer explicit over implicit, but don't be verbose
- When in doubt, choose the simpler solution
- Maintain consistency with existing codebase style
- Focus on meeting the requirements exactly - not more, not less
- Ensure all endpoints are functional and properly secured
- Test endpoints with appropriate access levels before considering complete
- Keep business logic separate from views - use services or model methods

